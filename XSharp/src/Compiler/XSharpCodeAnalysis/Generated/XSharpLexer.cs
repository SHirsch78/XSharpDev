//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6.1-SNAPSHOT
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\XSharp\Dev\XSharp\src\Compiler\XSharpCodeAnalysis\Parser\XSharpLexer.g4 by ANTLR 4.6.1-SNAPSHOT

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace LanguageService.CodeAnalysis.XSharp.SyntaxParser {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6.1-SNAPSHOT")]
[System.CLSCompliant(false)]
public partial class XSharpLexer : Lexer {
	public const int
		FIRST_KEYWORD=1, ACCESS=2, ALIGN=3, AS=4, ASPEN=5, ASSIGN=6, BEGIN=7, 
		BREAK=8, CALLBACK=9, CASE=10, CAST=11, CLASS=12, CLIPPER=13, DECLARE=14, 
		DEFINE=15, DIM=16, DLL=17, DLLEXPORT=18, DO=19, DOWNTO=20, ELSE=21, ELSEIF=22, 
		END=23, ENDCASE=24, ENDDO=25, ENDIF=26, EXIT=27, EXPORT=28, FASTCALL=29, 
		FIELD=30, FOR=31, FUNCTION=32, GLOBAL=33, HIDDEN=34, IF=35, IIF=36, INHERIT=37, 
		INIT1=38, INIT2=39, INIT3=40, INSTANCE=41, IS=42, IN=43, LOCAL=44, LOOP=45, 
		MEMBER=46, MEMVAR=47, METHOD=48, NAMEOF=49, NEXT=50, OTHERWISE=51, PARAMETERS=52, 
		PASCAL=53, PRIVATE=54, PROCEDURE=55, PROTECTED=56, PUBLIC=57, RECOVER=58, 
		RETURN=59, SELF=60, SEQUENCE=61, SIZEOF=62, STATIC=63, STEP=64, STRICT=65, 
		SUPER=66, THISCALL=67, TO=68, TYPEOF=69, UNION=70, UPTO=71, USING=72, 
		WHILE=73, WINCALL=74, CATCH=75, FINALLY=76, THROW=77, FIRST_POSITIONAL_KEYWORD=78, 
		ABSTRACT=79, AUTO=80, CASTCLASS=81, CONSTRUCTOR=82, CONST=83, DEFAULT=84, 
		DELEGATE=85, DESTRUCTOR=86, ENUM=87, EVENT=88, EXPLICIT=89, FOREACH=90, 
		GET=91, IMPLEMENTS=92, IMPLICIT=93, IMPLIED=94, INITONLY=95, INTERFACE=96, 
		INTERNAL=97, LOCK=98, NAMESPACE=99, NEW=100, OPERATOR=101, OUT=102, PARTIAL=103, 
		PROPERTY=104, REPEAT=105, SCOPE=106, SEALED=107, SET=108, STRUCTURE=109, 
		TRY=110, UNTIL=111, VALUE=112, VIRTUAL=113, VOSTRUCT=114, ADD=115, ARGLIST=116, 
		ASCENDING=117, ASYNC=118, ASTYPE=119, AWAIT=120, BY=121, CHECKED=122, 
		DESCENDING=123, EQUALS=124, EXTERN=125, FIXED=126, FROM=127, GROUP=128, 
		INIT=129, INTO=130, JOIN=131, LET=132, NOP=133, OF=134, ON=135, ORDERBY=136, 
		OVERRIDE=137, PARAMS=138, REMOVE=139, SELECT=140, SWITCH=141, UNCHECKED=142, 
		UNSAFE=143, VAR=144, VOLATILE=145, WHEN=146, WHERE=147, YIELD=148, WITH=149, 
		LAST_POSITIONAL_KEYWORD=150, FIRST_TYPE=151, ARRAY=152, BYTE=153, CODEBLOCK=154, 
		DATE=155, DWORD=156, FLOAT=157, INT=158, LOGIC=159, LONGINT=160, OBJECT=161, 
		PSZ=162, PTR=163, REAL4=164, REAL8=165, REF=166, SHORTINT=167, STRING=168, 
		SYMBOL=169, USUAL=170, VOID=171, WORD=172, CHAR=173, INT64=174, UINT64=175, 
		DYNAMIC=176, DECIMAL=177, DATETIME=178, CURRENCY=179, BINARY=180, NINT=181, 
		NUINT=182, LAST_TYPE=183, UDC_KEYWORD=184, SCRIPT_REF=185, SCRIPT_LOAD=186, 
		ASSIGNMENT=187, DEFERRED=188, ENDCLASS=189, EXPORTED=190, FREEZE=191, 
		FINAL=192, INLINE=193, INTRODUCE=194, NOSAVE=195, READONLY=196, SHARING=197, 
		SHARED=198, SYNC=199, ENDDEFINE=200, LPARAMETERS=201, OLEPUBLIC=202, EXCLUDE=203, 
		THISACCESS=204, HELPSTRING=205, DIMENSION=206, NOINIT=207, EACH=208, THEN=209, 
		FOX_M=210, TEXT=211, ENDTEXT=212, ADDITIVE=213, FLAGS=214, PRETEXT=215, 
		NOSHOW=216, TEXTMERGE=217, LAST_KEYWORD=218, FIRST_NULL=219, NIL=220, 
		NULL=221, NULL_ARRAY=222, NULL_CODEBLOCK=223, NULL_DATE=224, NULL_OBJECT=225, 
		NULL_PSZ=226, NULL_PTR=227, NULL_STRING=228, NULL_SYMBOL=229, LAST_NULL=230, 
		FIRST_OPERATOR=231, LT=232, LTE=233, GT=234, GTE=235, EQ=236, EEQ=237, 
		SUBSTR=238, NEQ=239, NEQ2=240, INC=241, DEC=242, PLUS=243, MINUS=244, 
		DIV=245, MOD=246, EXP=247, LSHIFT=248, RSHIFT=249, TILDE=250, MULT=251, 
		QQMARK=252, QMARK=253, AND=254, OR=255, NOT=256, VO_NOT=257, VO_AND=258, 
		VO_OR=259, VO_XOR=260, ASSIGN_OP=261, ASSIGN_ADD=262, ASSIGN_SUB=263, 
		ASSIGN_EXP=264, ASSIGN_MUL=265, ASSIGN_DIV=266, ASSIGN_MOD=267, ASSIGN_BITAND=268, 
		ASSIGN_BITOR=269, ASSIGN_LSHIFT=270, ASSIGN_RSHIFT=271, ASSIGN_XOR=272, 
		ASSIGN_QQMARK=273, LOGIC_AND=274, LOGIC_OR=275, LOGIC_NOT=276, LOGIC_XOR=277, 
		FOX_AND=278, FOX_OR=279, FOX_NOT=280, FOX_XOR=281, LPAREN=282, RPAREN=283, 
		LCURLY=284, RCURLY=285, LBRKT=286, RBRKT=287, COLON=288, COMMA=289, PIPE=290, 
		AMP=291, ADDROF=292, ALIAS=293, DOT=294, COLONCOLON=295, BACKSLASH=296, 
		ELLIPSIS=297, BACKBACKSLASH=298, LAST_OPERATOR=299, FIRST_CONSTANT=300, 
		FALSE_CONST=301, TRUE_CONST=302, HEX_CONST=303, BIN_CONST=304, INT_CONST=305, 
		DATE_CONST=306, DATETIME_CONST=307, REAL_CONST=308, INVALID_NUMBER=309, 
		SYMBOL_CONST=310, CHAR_CONST=311, STRING_CONST=312, ESCAPED_STRING_CONST=313, 
		INTERPOLATED_STRING_CONST=314, INCOMPLETE_STRING_CONST=315, TEXT_STRING_CONST=316, 
		BRACKETED_STRING_CONST=317, BINARY_CONST=318, LAST_CONSTANT=319, PP_FIRST=320, 
		PP_COMMAND=321, PP_DEFINE=322, PP_ELSE=323, PP_ENDIF=324, PP_ENDREGION=325, 
		PP_ERROR=326, PP_IFDEF=327, PP_IFNDEF=328, PP_INCLUDE=329, PP_LINE=330, 
		PP_REGION=331, PP_TRANSLATE=332, PP_UNDEF=333, PP_WARNING=334, PP_LAST=335, 
		MACRO=336, UDCSEP=337, ID=338, KWID=339, PRAGMA=340, DOC_COMMENT=341, 
		SL_COMMENT=342, ML_COMMENT=343, LINE_CONT=344, LINE_CONT_OLD=345, SEMI=346, 
		WS=347, NL=348, EOS=349, UNRECOGNIZED=350, LAST=351;
	public const int
		XMLDOCCHANNEL=2, DEFOUTCHANNEL=3, PREPROCESSORCHANNEL=4;
	public static string[] modeNames = {
		"DEFAULT_MODE"
	};

	public static readonly string[] ruleNames = {
		"UNRECOGNIZED"
	};


	public XSharpLexer(ICharStream input)
		: base(input)
	{
		_interp = new LexerATNSimulator(this,_ATN);
	}

	private static readonly string[] _LiteralNames = {
	};
	private static readonly string[] _SymbolicNames = {
		null, "FIRST_KEYWORD", "ACCESS", "ALIGN", "AS", "ASPEN", "ASSIGN", "BEGIN", 
		"BREAK", "CALLBACK", "CASE", "CAST", "CLASS", "CLIPPER", "DECLARE", "DEFINE", 
		"DIM", "DLL", "DLLEXPORT", "DO", "DOWNTO", "ELSE", "ELSEIF", "END", "ENDCASE", 
		"ENDDO", "ENDIF", "EXIT", "EXPORT", "FASTCALL", "FIELD", "FOR", "FUNCTION", 
		"GLOBAL", "HIDDEN", "IF", "IIF", "INHERIT", "INIT1", "INIT2", "INIT3", 
		"INSTANCE", "IS", "IN", "LOCAL", "LOOP", "MEMBER", "MEMVAR", "METHOD", 
		"NAMEOF", "NEXT", "OTHERWISE", "PARAMETERS", "PASCAL", "PRIVATE", "PROCEDURE", 
		"PROTECTED", "PUBLIC", "RECOVER", "RETURN", "SELF", "SEQUENCE", "SIZEOF", 
		"STATIC", "STEP", "STRICT", "SUPER", "THISCALL", "TO", "TYPEOF", "UNION", 
		"UPTO", "USING", "WHILE", "WINCALL", "CATCH", "FINALLY", "THROW", "FIRST_POSITIONAL_KEYWORD", 
		"ABSTRACT", "AUTO", "CASTCLASS", "CONSTRUCTOR", "CONST", "DEFAULT", "DELEGATE", 
		"DESTRUCTOR", "ENUM", "EVENT", "EXPLICIT", "FOREACH", "GET", "IMPLEMENTS", 
		"IMPLICIT", "IMPLIED", "INITONLY", "INTERFACE", "INTERNAL", "LOCK", "NAMESPACE", 
		"NEW", "OPERATOR", "OUT", "PARTIAL", "PROPERTY", "REPEAT", "SCOPE", "SEALED", 
		"SET", "STRUCTURE", "TRY", "UNTIL", "VALUE", "VIRTUAL", "VOSTRUCT", "ADD", 
		"ARGLIST", "ASCENDING", "ASYNC", "ASTYPE", "AWAIT", "BY", "CHECKED", "DESCENDING", 
		"EQUALS", "EXTERN", "FIXED", "FROM", "GROUP", "INIT", "INTO", "JOIN", 
		"LET", "NOP", "OF", "ON", "ORDERBY", "OVERRIDE", "PARAMS", "REMOVE", "SELECT", 
		"SWITCH", "UNCHECKED", "UNSAFE", "VAR", "VOLATILE", "WHEN", "WHERE", "YIELD", 
		"WITH", "LAST_POSITIONAL_KEYWORD", "FIRST_TYPE", "ARRAY", "BYTE", "CODEBLOCK", 
		"DATE", "DWORD", "FLOAT", "INT", "LOGIC", "LONGINT", "OBJECT", "PSZ", 
		"PTR", "REAL4", "REAL8", "REF", "SHORTINT", "STRING", "SYMBOL", "USUAL", 
		"VOID", "WORD", "CHAR", "INT64", "UINT64", "DYNAMIC", "DECIMAL", "DATETIME", 
		"CURRENCY", "BINARY", "NINT", "NUINT", "LAST_TYPE", "UDC_KEYWORD", "SCRIPT_REF", 
		"SCRIPT_LOAD", "ASSIGNMENT", "DEFERRED", "ENDCLASS", "EXPORTED", "FREEZE", 
		"FINAL", "INLINE", "INTRODUCE", "NOSAVE", "READONLY", "SHARING", "SHARED", 
		"SYNC", "ENDDEFINE", "LPARAMETERS", "OLEPUBLIC", "EXCLUDE", "THISACCESS", 
		"HELPSTRING", "DIMENSION", "NOINIT", "EACH", "THEN", "FOX_M", "TEXT", 
		"ENDTEXT", "ADDITIVE", "FLAGS", "PRETEXT", "NOSHOW", "TEXTMERGE", "LAST_KEYWORD", 
		"FIRST_NULL", "NIL", "NULL", "NULL_ARRAY", "NULL_CODEBLOCK", "NULL_DATE", 
		"NULL_OBJECT", "NULL_PSZ", "NULL_PTR", "NULL_STRING", "NULL_SYMBOL", "LAST_NULL", 
		"FIRST_OPERATOR", "LT", "LTE", "GT", "GTE", "EQ", "EEQ", "SUBSTR", "NEQ", 
		"NEQ2", "INC", "DEC", "PLUS", "MINUS", "DIV", "MOD", "EXP", "LSHIFT", 
		"RSHIFT", "TILDE", "MULT", "QQMARK", "QMARK", "AND", "OR", "NOT", "VO_NOT", 
		"VO_AND", "VO_OR", "VO_XOR", "ASSIGN_OP", "ASSIGN_ADD", "ASSIGN_SUB", 
		"ASSIGN_EXP", "ASSIGN_MUL", "ASSIGN_DIV", "ASSIGN_MOD", "ASSIGN_BITAND", 
		"ASSIGN_BITOR", "ASSIGN_LSHIFT", "ASSIGN_RSHIFT", "ASSIGN_XOR", "ASSIGN_QQMARK", 
		"LOGIC_AND", "LOGIC_OR", "LOGIC_NOT", "LOGIC_XOR", "FOX_AND", "FOX_OR", 
		"FOX_NOT", "FOX_XOR", "LPAREN", "RPAREN", "LCURLY", "RCURLY", "LBRKT", 
		"RBRKT", "COLON", "COMMA", "PIPE", "AMP", "ADDROF", "ALIAS", "DOT", "COLONCOLON", 
		"BACKSLASH", "ELLIPSIS", "BACKBACKSLASH", "LAST_OPERATOR", "FIRST_CONSTANT", 
		"FALSE_CONST", "TRUE_CONST", "HEX_CONST", "BIN_CONST", "INT_CONST", "DATE_CONST", 
		"DATETIME_CONST", "REAL_CONST", "INVALID_NUMBER", "SYMBOL_CONST", "CHAR_CONST", 
		"STRING_CONST", "ESCAPED_STRING_CONST", "INTERPOLATED_STRING_CONST", "INCOMPLETE_STRING_CONST", 
		"TEXT_STRING_CONST", "BRACKETED_STRING_CONST", "BINARY_CONST", "LAST_CONSTANT", 
		"PP_FIRST", "PP_COMMAND", "PP_DEFINE", "PP_ELSE", "PP_ENDIF", "PP_ENDREGION", 
		"PP_ERROR", "PP_IFDEF", "PP_IFNDEF", "PP_INCLUDE", "PP_LINE", "PP_REGION", 
		"PP_TRANSLATE", "PP_UNDEF", "PP_WARNING", "PP_LAST", "MACRO", "UDCSEP", 
		"ID", "KWID", "PRAGMA", "DOC_COMMENT", "SL_COMMENT", "ML_COMMENT", "LINE_CONT", 
		"LINE_CONT_OLD", "SEMI", "WS", "NL", "EOS", "UNRECOGNIZED", "LAST"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete("Use IRecognizer.Vocabulary instead.")]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "XSharpLexer.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string[] ModeNames { get { return modeNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x2\x161\a\b\x1\x4"+
		"\x2\t\x2\x3\x2\x3\x2\x2\x2\x2\x3\x3\x2\x160\x3\x2\x2\x6\x2\x3\x3\x2\x2"+
		"\x2\x3\x5\x3\x2\x2\x2\x5\x6\v\x2\x2\x2\x6\x4\x3\x2\x2\x2\x3\x2\x2";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace LanguageService.CodeAnalysis.XSharp.SyntaxParser
