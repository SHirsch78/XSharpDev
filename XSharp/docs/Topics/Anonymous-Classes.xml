<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../helpproject.xsl" ?>
<topic template="Default" lasteditedby="robert" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../helpproject.xsd">
  <title translate="true">Anonymous Types</title>
  <body>
    <header>
      <para styleclass="Heading1"><text styleclass="Heading1" translate="true">Anonymous Types</text></para>
    </header>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first. </text><br/><text styleclass="Normal" translate="true">The type name is generated by the compiler and is not available at the source code level. The type of each property is inferred by the compiler. </text></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The syntax for an anonymous class is :</text></para>
    <para styleclass="Normal"></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">VAR o := CLASS { Name := &quot;test&quot;, Value := &quot;something&quot; }</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">In LINQ this may lead to:</text></para>
    <para styleclass="Normal"></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">VAR </text><tab /><text styleclass="Code Example" translate="true">result := from c in db.Customers where c.Orders.Count &gt; 0 ;</text><br/><tab /><text styleclass="Code Example" translate="true">select CLASS{ ID := C.CustomerID, Name := C.CustomerName, OrderCount := C.Orders.Count}</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Code Example"><text styleclass="Normal" translate="true">In this case the object will have the properties </text><text styleclass="Normal" style="font-weight:bold;" translate="true">ID</text><text styleclass="Normal" translate="true">, </text><text styleclass="Normal" style="font-weight:bold;" translate="true">Name</text><text styleclass="Normal" translate="true"> and </text><text styleclass="Normal" style="font-weight:bold;" translate="true">OrderCount</text><text styleclass="Normal" translate="true"> (all explicitely given)</text></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">If you select named properties from another object you can omit the &lt;Name&gt; := part. In that case the compiler will simply use the same name:</text></para>
    <para styleclass="Normal"></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">VAR </text><tab /><text styleclass="Code Example" translate="true">result := from c in db.Customers where c.Orders.Count &gt; 0 ;</text><br/><tab /><text styleclass="Code Example" translate="true">select CLASS{ C.CustomerID, C.CustomerName, OrderCount := C.Orders.Count}</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Code Example"><text styleclass="Normal" translate="true">In this case the anonymous class will have the properties </text><text styleclass="Normal" style="font-weight:bold;" translate="true">CustomerID</text><text styleclass="Normal" translate="true">, </text><text styleclass="Normal" style="font-weight:bold;" translate="true">CustomerName</text><text styleclass="Normal" translate="true"> (inherited from C) and </text><text styleclass="Normal" style="font-weight:bold;" translate="true">OrderCount</text><text styleclass="Normal" translate="true"> (explicitely given)</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Anonymous types contain one or more public read-only properties. No other kinds of class members, such as methods or events, are valid. </text><br/><text styleclass="Normal" translate="true">The expression that is used to initialize a property cannot be null, an anonymous function, or a pointer type.</text></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The most common scenario is to initialize an anonymous type with properties from another type. In the following example, assume that a class exists that is named Product. Class Product includes Color and Price properties, together with other properties that you are not interested in. Variable products is a collection of Product objects. The anonymous type declaration starts with the new keyword. The declaration initializes a new type that uses only two properties from Product. This causes a smaller amount of data to be returned in the query.</text></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">If you do not specify member names in the anonymous type, the compiler gives the anonymous type members the same name as the property being used to initialize them. You must provide a name for a property that is being initialized with an expression, as shown in the previous example. In the following example, the names of the properties of the anonymous type are Color and Price.</text></para>
    <para styleclass="Normal"></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">var productQuery := ;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;from prod in products ;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;select CLASS { prod:Color, prod:Price }</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">foreach var v in productQuery</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;Console.WriteLine(&quot;Color={0}, Price={1}&quot;, v:Color, v:Price)</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">next</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Typically, when you use an anonymous type to initialize a variable, you declare the variable as an implicitly typed local variable by using var. The type name cannot be specified in the variable declaration because only the compiler has access to the underlying name of the anonymous type.</text></para>
    <para styleclass="Normal"></para>
    <para styleclass="Heading2"><text styleclass="Heading2" translate="true">Remarks</text></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Anonymous types are class types that derive directly from object, and that cannot be cast to any type except object. The compiler provides a name for each anonymous type, although your application cannot access it. From the perspective of the common language runtime, an anonymous type is no different from any other reference type.</text></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">If two or more anonymous object initializers in an assembly specify a sequence of properties that are in the same order and that have the same names and types, the compiler treats the objects as instances of the same type. They share the same compiler-generated type information.</text></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">You cannot declare a field, a property, an event, or the return type of a method as having an anonymous type. Similarly, you cannot declare a formal parameter of a method, property, constructor, or indexer as having an anonymous type. To pass an anonymous type, or a collection that contains anonymous types, as an argument to a method, you can declare the parameter as type object. However, doing this defeats the purpose of strong typing. If you must store query results or pass them outside the method boundary, consider using an ordinary named struct or class instead of an anonymous type.</text></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Because the Equals and GetHashCode methods on anonymous types are defined in terms of the Equals and GetHashCode methods of the properties, two instances of the same anonymous type are equal only if all their properties are equal.</text></para>
    <para styleclass="Normal"></para>
  </body>
</topic>
